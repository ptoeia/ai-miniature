# Creem Webhook 处理流程文档

## 🎯 业务模式概述

我们的系统采用**订阅+积分消耗**模式：
- 用户订阅获得月度积分配额
- 使用 AI 功能时按实际消耗扣除积分
- 预留一次性积分包功能（暂未启用）

## 💳 Creem 自动续费机制

### 支付方式保存
```
用户首次订阅时:
1. 用户在 Creem 结账页面输入信用卡信息
2. Creem 安全保存支付方式（符合 PCI DSS 标准）
3. 每月到期时，Creem 自动使用保存的支付方式扣款
4. 就像 Netflix、Apple 订阅一样的标准模式
```

### 自动续费流程
- **保存方式**: Creem 通过 Stripe 等支付处理商安全保存用户信用卡
- **自动扣款**: 每月到期日自动从保存的支付方式扣费
- **失败处理**: 扣款失败时订阅进入逾期状态，给用户时间更新支付方式

## 🛑 订阅管理：Creem 客户门户

### 🎉 好消息：您不需要实现取消页面！
Creem 提供了完整的**客户门户**（Customer Portal），用户可以自助管理：

#### 用户如何访问？
1. **自动邮件**: 每次付款后，用户收到包含"魔法链接"的邮件
2. **API 生成**: 您可以通过 API 为用户生成门户链接
3. **直接访问**: 用户可以通过 Creem 官网访问

#### 客户门户功能
✅ **取消订阅** - 立即停止自动续费  
✅ **更新支付方式** - 更换信用卡信息  
✅ **查看账单历史** - 所有付款记录  
✅ **申请发票** - 下载正式发票  
✅ **联系客服** - 直接联系 Creem 团队  

### 🔧 可选：集成客户门户到您的应用
```typescript
// 为用户生成客户门户链接
const response = await axios.post(
  'https://api.creem.io/v1/customers/billing',
  { customer_id: "cust_xxxxxxx" },
  { headers: { "x-api-key": "your_api_key" } }
);

// 重定向用户到门户
window.location.href = response.data.customer_portal_link;
```

## 💰 退款政策：您不会亏损！

### 🛡️ 重要：Creem 处理所有退款
- **退款责任**: 用户找 **Creem** 申请退款，不是找您
- **您的保护**: Creem 已经向您支付了费用，退款由 Creem 承担
- **标准做法**: 这是 SaaS 平台的标准模式（如 Stripe、App Store）

### 🎯 用户投诉处理：Creem 负责客服！

#### 用户有问题时的联系流程：
```
用户有投诉/问题:
1. 用户首先联系 Creem 客服（不是您）
   → Creem 客户门户提供直接客服联系
   → 用户收到的邮件也包含 Creem 客服信息
   
2. 如果是产品功能问题，Creem 可能会转介给您
   → 但退款/账单问题仍由 Creem 处理
   
3. 最终决定权在 Creem
   → 退款批准/拒绝由 Creem 决定
   → 您不需要承担退款责任
```

#### 🚨 如果用户直接联系您：
- **态度友好**：倾听用户问题
- **引导转介**：告诉用户联系 Creem 客服处理退款
- **不要承诺**：不要直接承诺退款，因为这不是您的责任
- **记录问题**：如果是产品 bug，记录并修复

### 退款处理流程
```
用户申请退款:
1. 用户联系 Creem 客服（不是您）
2. Creem 评估退款请求
3. 如果同意退款，Creem 退钱给用户
4. 您已经收到的钱不会被收回
5. 您的系统会收到 subscription.canceled webhook
```

### 积分消耗与退款
- **部分使用**: 用户消耗了部分积分，仍可能获得部分退款
- **您的处理**: 收到取消 webhook 时，停止提供服务即可
- **损失承担**: 退款损失由 Creem 承担，不是您

### 📞 客服分工明确
| 问题类型 | 处理方 | 您的角色 |
|---------|--------|----------|
| 账单问题 | Creem | 无需参与 |
| 退款申请 | Creem | 无需参与 |
| 支付失败 | Creem | 无需参与 |
| 产品功能问题 | 您 | 提供技术支持 |
| 产品使用教程 | 您 | 提供使用指导 |

### 🔒 法律保护
作为 **Merchant of Record**，Creem：
- 承担所有支付相关的法律责任
- 处理信用卡争议 (Chargeback)
- 管理税务合规
- 负责客户服务争议解决

## 📋 Webhook 事件类型

### 💡 重要概念：付款 vs 收款确认
很多人会疑惑 `checkout.completed` 和 `subscription.paid` 的区别，它们都涉及付款，但代表支付流程的不同阶段：

- **`checkout.completed`**: 用户完成了支付表单提交（"我已经付款了"）
- **`subscription.paid`**: 支付提供商确认资金到账（"钱真的收到了"）

类比：就像网购时点击"立即付款"和收到"付款成功"短信的区别。

### 1️⃣ `checkout.completed` - 结账完成
**发生时间**: 用户在支付页面成功付款
**含义**: 支付流程完成
**处理逻辑**: 
- ✅ **订阅产品**: 只记录日志，不处理积分
- 🚧 **一次性产品**: 功能暂时禁用（代码已预留）

### 2️⃣ `subscription.paid` - 订阅付款确认
**发生时间**: Creem 确认订阅付款已处理
**含义**: 订阅费用收到，可以提供服务
**处理逻辑**: 
- ✅ **创建/更新订阅记录**
- ✅ **授予月度积分** (核心逻辑)
- ✅ **幂等性检查** (防止重复处理)

### 3️⃣ `subscription.active` - 订阅激活
**发生时间**: 订阅状态变为活跃
**含义**: 订阅正式生效
**处理逻辑**: 
- ✅ **只同步订阅状态**
- ❌ **不授予积分** (避免重复)

### 4️⃣ `subscription.updated` - 订阅更新
**发生时间**: 订阅信息发生变更
**处理逻辑**: 同步状态变更

### 5️⃣ `subscription.canceled` - 订阅取消
**发生时间**: 用户取消订阅
**处理逻辑**: 更新订阅状态为已取消

## ⏰ 典型流程时序

### 🆕 新用户订阅流程
```
用户购买订阅
    ↓
1. checkout.completed (付款完成)
   → 记录日志: "订阅结账完成，等待付款确认"
    ↓ (几秒内)
2. subscription.paid (付款确认) ⭐️ 核心处理
   → 创建订阅记录
   → 授予月度积分 (如 500 积分)
    ↓ (几秒内)
3. subscription.active (状态激活)
   → 更新订阅状态为 active
```

### 🔄 月度自动续费流程
订阅是**自动续费**模式，每月到期时 Creem 会自动扣款：

```
订阅到期时间 (如每月15日)
    ↓
Creem 自动从用户信用卡扣款
    ↓
扣款成功:
1. subscription.paid (续费付款确认) ⭐️ 核心处理
   → 更新订阅周期 (current_period_start/end)
   → 授予新的月度积分 (积分重置)
    ↓
2. subscription.active (状态确认)
   → 确认订阅仍为活跃状态

扣款失败:
1. subscription.past_due
   → 订阅状态变为逾期
   → 用户需要更新支付方式
```

### ❌ 订阅取消流程
```
用户在 Creem 客户门户取消订阅
    ↓
1. subscription.canceled
   → 更新订阅状态
   → 设置取消时间
   → 根据 cancel_at_period_end 决定何时停止服务
   
   立即取消: 服务马上停止
   周期结束取消: 用到当前周期结束再停止
```

## 🔧 技术实现细节

### 幂等性保护
为防止重复处理，我们通过检查 `currentPeriodStart` 确保同一个计费周期只处理一次：
```typescript
const newPeriodStart = Math.floor(new Date(subscription.current_period_start_date).getTime() / 1000);

if (existingSubscription && existingSubscription.currentPeriodStart === newPeriodStart) {
  console.log(`Subscription payment for period ${newPeriodStart} already processed, skipping.`);
  break;
}
```

### 数据库操作
- **订阅处理**: 调用 `process_paid_subscription` RPC 函数
- **状态同步**: 调用 `syncSubscription` 函数
- **产品同步**: 调用 `upsertProductAndGetId` 函数

### 错误处理
- 签名验证失败 → 返回 400 错误
- 数据库操作失败 → 记录错误日志并抛出异常
- 缺少必要字段 → 抛出描述性错误

## 🚧 预留功能：一次性积分包

目前代码中已预留一次性积分包的完整实现，但功能暂时禁用：

```typescript
// 当前状态：功能禁用
console.log(`One-time purchase feature is disabled. Product: ${productFromWebhook.name}`);

// 预留代码：取消注释即可启用
/* 
完整的一次性购买处理逻辑
- 记录购买记录
- 立即授予积分
- 事务性操作确保一致性
*/
```

## ⚠️ 重要注意事项

### 1. 积分授予原则
- **只在 `subscription.paid` 事件中授予积分**
- 其他事件只做状态同步，避免重复授予

### 2. 事件处理顺序
- 事件可能不按顺序到达
- 必须确保每个事件都能独立正确处理
- 通过幂等性检查避免重复操作

### 3. 数据一致性
- 使用数据库事务确保操作原子性
- 失败时自动回滚，保证数据一致性

### 4. 监控和日志
- 记录完整的 webhook 事件数据用于调试
- 记录所有关键操作的结果
- 错误时提供详细的错误信息

### 5. 自动续费机制
- **积分重置**: 每月续费时，用户获得新的月度积分配额
- **周期管理**: 通过 `current_period_start/end` 跟踪计费周期
- **失败处理**: 续费失败时订阅进入逾期状态，需要用户更新支付方式

## 🔍 调试和故障排除

### 常见问题
1. **重复积分授予**: 检查幂等性逻辑
2. **订阅状态不同步**: 检查 `syncSubscription` 函数
3. **积分未授予**: 检查 `subscription.paid` 事件处理
4. **续费失败**: 检查用户支付方式状态

### 日志查看
系统会记录：
- 完整的 webhook 事件数据
- 每个处理步骤的结果
- 错误详情和堆栈信息

### 手动验证
可以通过以下方式验证：
- 检查 `subscription` 表中的记录
- 查看用户积分余额变化
- 对比 Creem 后台的订阅状态
- 验证续费周期的正确性